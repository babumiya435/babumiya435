JS:

1.Arrow function vs Normal function in JS
	https://betterprogramming.pub/difference-between-regular-functions-and-arrow-functions-f65639aba256
	1. Syntax
	// (param1, param2, paramN) => expression
	// ES5
	var add = function(x, y) {
  		return x + y;
	};
	// ES6
	let add = (x, y) => { return x + y };
	2. Arguments binding
		-Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.
		-Arrow functions do not have an arguments binding. However, they have access to the arguments object of the closest non-arrow parent function. Named and rest parameters are heavily relied upon to capture the arguments passed to arrow functions.
		-Arrow functions can never be used as constructor functions. Hence, they can never be invoked with the new keyword. As such, a prototype property does not exist for an arrow function.
		-The value of this inside an arrow function remains the same throughout the lifecycle of the function and is always bound to the value of this in the closest non-arrow parent function.
	3. Use of this keyword:
	Unlike regular functions, arrow functions do not have their own this. The value of this inside an arrow function remains the same throughout the lifecycle of the function and is always bound to the value of this in the closest non-arrow parent function.
	const me = {
    			name : "Sameer",
    			printName : ()=>{
        			return `My name is ${this.name}`  // no this reference inside normal function
    			},
    			printNameRegular: function() {
        			return `My name is ${this.name}`  // this reference is availble inside normal function
    			}
		}
		console.log(me.printName());
		console.log(me.printNameRegular());
	4. Using new keyword:
	Regular functions created using function declarations or expressions are constructible and callable. Since regular functions are constructible, they can be called using the new keyword.
	However, the arrow functions are only callable and not constructible, i.e arrow functions can never be used as constructor functions. Hence, they can never be invoked with the new keyword.
	const constructorNormal = function(a,b){
    					console.log(a + b);
				}
	const constructorArrow = (a,b)=>{
    					console.log(a + b);
				}
	const obj1 = new constructorNormal(2,3);
	const obj2 = new constructorArrow(2,3);
	console.log(obj1);  // normal method is both callable and constructable
	console.log(obj2);  // arrow method only callable not constructable

	5. No duplicate named parameters:
	Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.
	It means that the following is valid JavaScript:
		function add(x, x){}
	It is not, however, when using strict mode:
		'use strict';
		function add(x, x){}
		// SyntaxError: duplicate formal argument x
	With arrow functions, duplicate named arguments are always, regardless of strict or non-strict mode, invalid.
		(x, x) => {}
		// SyntaxError: duplicate argument names not allowed in this context
	-Syntax
	-No arguments (arguments are array-like objects) (we can use rest parameter way of accessing)
	-No prototype object for the Arrow function
	-Cannot be invoked with a new keyword (Not a constructor function)
	-No own this (call, apply & bind won't work as expected)
	-It cannot be used as a Generator function
	-Duplicate-named parameters are not allowed
	
	const norm = function(a){
    		return a + this.b;
	}
	const arro = (a)=>{
    		console.log(a);
   		return a + this.b;
	}
	let res = norm.call(data,5);
	console.log(res);
	let res1 = arro.call(data,5);
	console.log(res1);
	let res2 = arro.apply(data,[6]);
	console.log(res2);
	let add2 = arro.bind(data,2);
	console.log(add2());

	https://blog.bitsrc.io/arrow-functions-vs-regular-functions-in-javascript-458ccd863bc1

		
	

2.Map , filter, reduce methods

	Higher Order Functions:
		A higher-order function is a function that takes one or more functions as arguments or returns a function as its result. map, filter, andreduce are all higher order functions, which take a function as an argument.
		All the functions are part of the JavaScript Array prototype which means they must be called directly on an array.

		const arr = [1, 2, 3]
		arr.map()
		arr.filter()
		arr.reduce()
		When we are using map,filter, and reduce, we cannot:
		-break the loop
		-use continue
	map → Executes a function on each element of an array:
		Every element of the array is passed to the callback function and returns a new array with the same length.
		When to use map: If we want to perform the same operation/transformation on each element of the array and get back a new array of the same length with the transformed values.
	filter → Remove items which don’t satisfy a condition:
		Every element of the array is passed to the callback function. On each iteration, if the callback returns true, then that element will be added to the new array, otherwise, it is not added to the new array.
	Reduce → Creates a single value from elements of Array:
		While using reduce, we need to declare the initial value of accumulator(final result). On each iteration, inside the callback we perform some operation and that will be added to the accumulator.

3.Call back and call back hell
4.Hoisting with example
5.Virtual dom vs real dom
6.Event loop , call stack, stack queue
7.promise, settimeout
8.this keyword
9.call, bind, apply

React:

1.Hooks
2.Pure component
3.Controlled vs uncontrolled component
4.what is heigher order component
5.problem drilling
6.passing data from child to parent vise versa
7.Redux
8.Life cycle hooks

Angular:

1.passing data from child to parent vise versa
2.Life cycle hooks
