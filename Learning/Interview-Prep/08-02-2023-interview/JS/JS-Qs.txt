JS:

https://jsbin.com/fazurusufi/3/edit?js,console
1.Arrow function vs Normal function in JS
	https://betterprogramming.pub/difference-between-regular-functions-and-arrow-functions-f65639aba256
	1. Syntax
	// (param1, param2, paramN) => expression
	// ES5
	var add = function(x, y) {
  		return x + y;
	};
	// ES6
	let add = (x, y) => { return x + y };
	2. Arguments binding
		-Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.
		-Arrow functions do not have an arguments binding. However, they have access to the arguments object of the closest non-arrow parent function. Named and rest parameters are heavily relied upon to capture the arguments passed to arrow functions.
		-Arrow functions can never be used as constructor functions. Hence, they can never be invoked with the new keyword. As such, a prototype property does not exist for an arrow function.
		-The value of this inside an arrow function remains the same throughout the lifecycle of the function and is always bound to the value of this in the closest non-arrow parent function.
	3. Use of this keyword:
	Unlike regular functions, arrow functions do not have their own this. The value of this inside an arrow function remains the same throughout the lifecycle of the function and is always bound to the value of this in the closest non-arrow parent function.
	const me = {
    			name : "Sameer",
    			printName : ()=>{
        			return `My name is ${this.name}`  // no this reference inside normal function
    			},
    			printNameRegular: function() {
        			return `My name is ${this.name}`  // this reference is availble inside normal function
    			}
		}
		console.log(me.printName());
		console.log(me.printNameRegular());
	4. Using new keyword:
	Regular functions created using function declarations or expressions are constructible and callable. Since regular functions are constructible, they can be called using the new keyword.
	However, the arrow functions are only callable and not constructible, i.e arrow functions can never be used as constructor functions. Hence, they can never be invoked with the new keyword.
	const constructorNormal = function(a,b){
    					console.log(a + b);
				}
	const constructorArrow = (a,b)=>{
    					console.log(a + b);
				}
	const obj1 = new constructorNormal(2,3);
	const obj2 = new constructorArrow(2,3);
	console.log(obj1);  // normal method is both callable and constructable
	console.log(obj2);  // arrow method only callable not constructable

	5. No duplicate named parameters:
	Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.
	It means that the following is valid JavaScript:
		function add(x, x){}
	It is not, however, when using strict mode:
		'use strict';
		function add(x, x){}
		// SyntaxError: duplicate formal argument x
	With arrow functions, duplicate named arguments are always, regardless of strict or non-strict mode, invalid.
		(x, x) => {}
		// SyntaxError: duplicate argument names not allowed in this context
	-Syntax
	-No arguments (arguments are array-like objects) (we can use rest parameter way of accessing)
	-No prototype object for the Arrow function
	-Cannot be invoked with a new keyword (Not a constructor function)
	-No own this (call, apply & bind won't work as expected)
	-It cannot be used as a Generator function
	-Duplicate-named parameters are not allowed
	
	const norm = function(a){
    		return a + this.b;
	}
	const arro = (a)=>{
    		console.log(a);
   		return a + this.b;
	}
	let res = norm.call(data,5);
	console.log(res);
	let res1 = arro.call(data,5);
	console.log(res1);
	let res2 = arro.apply(data,[6]);
	console.log(res2);
	let add2 = arro.bind(data,2);
	console.log(add2());

	https://blog.bitsrc.io/arrow-functions-vs-regular-functions-in-javascript-458ccd863bc1

		
	

2.Map , filter, reduce methods

	Higher Order Functions:
		A higher-order function is a function that takes one or more functions as arguments or returns a function as its result. map, filter, andreduce are all higher order functions, which take a function as an argument.
		All the functions are part of the JavaScript Array prototype which means they must be called directly on an array.

		const arr = [1, 2, 3]
		arr.map()
		arr.filter()
		arr.reduce()
		When we are using map,filter, and reduce, we cannot:
		-break the loop
		-use continue
	map → Executes a function on each element of an array:
		Every element of the array is passed to the callback function and returns a new array with the same length.
		When to use map: If we want to perform the same operation/transformation on each element of the array and get back a new array of the same length with the transformed values.
	filter → Remove items which don’t satisfy a condition:
		Every element of the array is passed to the callback function. On each iteration, if the callback returns true, then that element will be added to the new array, otherwise, it is not added to the new array.
	Reduce → Creates a single value from elements of Array:
		While using reduce, we need to declare the initial value of accumulator(final result). On each iteration, inside the callback we perform some operation and that will be added to the accumulator.
	let users = [
        {
            userName : "student1"
        },
        {
            userName : "student2"
        },
        {
            userName : "student3"
        },
        {
            userName : "student4"
        }
    	]
	console.log(users);
	let marks = users.map((user)=>{
    	let marks = Math.random() * 100;
    	user.marks = marks;
    	return user;
	})
	console.log(marks);
	let passed = users.filter((user)=>{
    	return user.marks > 50;
	})
	console.log(passed);
	let team = passed.reduce((acc,user)=>{
    	if(user.marks > 70){
        	acc.push(user);
    	}
    	return acc;
	},[])

	console.log(team);

	https://code.tutsplus.com/tutorials/how-to-use-map-filter-reduce-in-javascript--cms-26209
	Gotchas: (.map)
	The callback you pass to map must have an explicit return statement, or map will spit out an array full of undefined. It's not hard to remember to include a return value, but it's not hard to forget. 

	If you do forget, map won't complain. Instead, it'll quietly hand back an array full of nothing. Silent errors like that can be surprisingly hard to debug. 

	Fortunately, this is the only gotcha with map. But it's a common enough pitfall that I'm obliged to emphasize: Always make sure your callback contains a return statement!
	
	Gotchas: (.filter):
	The callback you pass to map has to include a return statement if you want it to function properly. With filter, you also have to include a return statement (unless you're using arrow functions), and you must make sure it returns a boolean value.

	If you forget your return statement, your callback will return undefined, which filter will unhelpfully coerce to false. Instead of throwing an error, it will silently return an empty array! 

	If you go the other route and return something that's isn't explicitly true or false, then filter will try to figure out what you meant by applying JavaScript's type coercion rules. More often than not, this is a bug. And, just like forgetting your return statement, it'll be a silent one. 

	Always make sure your callbacks include an explicit return statement. And always make sure your callbacks in filter return true or false. Your sanity will thank you

	Gotchas: (.reduce)
	The three big gotchas with reduce are:

	forgetting to return
	forgetting an initial value
	expecting an array when reduce returns a single value

	Fortunately, the first two are easy to avoid. Deciding what your initial value should be depends on what you're doing, but you'll get the hang of it quickly.

	The last one might seem a bit strange. If reduce only ever returns a single value, why would you expect an array?

	There are a few good reasons for that. First, reduce always returns a single value, not always a single number. If you reduce an array of arrays, for instance, it will return a single array. If you're in the habit of reducing arrays, it would be fair to expect that an array containing a single item wouldn't be a special case.

	Second, if reduce did return an array with a single value, it would naturally play nice with map and filter, and other functions on arrays that you're likely to be using with it.
	
	.sort():
	https://dev.to/ivanadokic/javascript-array-methods-filter-map-reduce-and-sort-32m5
	The sort() method sorts the elements of an array in place and returns the sorted array.
	arr.sort([compareFunction])
	Ascending order:
	students.sort((a, b) => {
    		return a.age - b.age;
	});
	Descending order:
	students.sort((a, b) => b.age - a.age);
	Akshyai Saini : https://www.youtube.com/watch?v=zdp0zrpKzIE

3.Call back and call back hell
4.Hoisting with example
5.Virtual dom vs real dom
6.Event loop , call stack, stack queue
7.promise, settimeout
8.this keyword
9.call, bind, apply

